using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Runtime.InteropServices;
using System.Threading;
using System.Diagnostics;
using System.Text.RegularExpressions;
using System.Windows.Forms;

namespace GreyBush
{
    /// <summary>
    /// Debugger object responsable for controlling the target process
    /// 
    /// Capable of launching processin seperate desktop and auto clicking popup windows
    /// Controls process by invoking the windows debugging API
    /// </summary>
	class Debugger
	{
		#region Member_Variables

		// Settings value initiated by constructor.  These settings are a subset of the settings that come from the EngineSettings
        // and are all initialized by the values located in the main EngineSettings object.
		private DebuggerSettings settings = null;

		// Process information.
		private Process debuggee = null;
		private string debuggeePath = null;
		private string ProcessArguments = null;
		private bool is32bit = true;
		private bool doneStarting = true;

		// Debugger information
		private StringBuilder ErrorInformation = new StringBuilder("");

		// Positive Response Buttons to click - list of regex patterns to match against buttons on.
		private List<string> PositiveResponses = new List<string> { @"(&|)[Oo][Kk]", @"(&|)[Yy][Ee][Ss]", @"(&|)[Tt][Rr][Yy]", @"(&|)[Nn][Ee][Xx][Tt]", @"(&|)[Cc][Oo][Nn][Tt][Ii][Nn][Uu][Ee]" };

		// Event information.  Tracks time of each event and whether the program should initiate a termination sequence.
		private int lastEvent = 0;

		// Thread running the debuggee
		private Thread debuggerThread = null;
		private Thread WindowThread = null;
		private bool enterTerminateSequence = false;

		// Alternate Desktop values, for hiding the debuggee window
		private IntPtr DesktopHandle = IntPtr.Zero;
		private const string DesktopName = "GreyBush";

		#endregion Member_Variables

		#region Public_Functions

		/// <summary>
		/// Initialize a new instance of the debugger.
		/// </summary>
		/// <param name="LoadCoverageModule"></param>
		public Debugger(DebuggerSettings s/*, bool LoadCoverageModule = false*/)
		{
			this.settings = s;
			if (this.settings.HideMainWindow)
			{
				this.DesktopHandle = WinAPI.CreateDesktop(DesktopName, IntPtr.Zero, IntPtr.Zero, 0, (uint)WinAPI.ACCESS_MASK.GENERIC_ALL, IntPtr.Zero);
				if (this.DesktopHandle == IntPtr.Zero)
					throw new Exception("Unable to create Desktop");
			}
		}

		/// <summary>
		/// Gets the state of the debugger, true if it is processing an active debuggee, false otherwise.
		/// </summary>
		public bool IsRunning
		{
			get
			{
				try
				{
					if (this.debuggee == null)
						return false;
					return !this.debuggee.HasExited || !this.doneStarting;
				}
				catch
				{
					return false;
				}
			}
		}

		/// <summary>
		/// Gets the millisecond count that the last event occured at
		/// </summary>
		public int LastEvent
		{
			get
			{
				return this.lastEvent;
			}
		}

		/// <summary>
		/// Gets any event information output from the debugger that was generated by the debuggee
		/// </summary>
		public string DebugMessages
		{
			get
			{
				string returnValue = this.ErrorInformation.ToString();
				if (!this.settings.IgnoreExceptions || returnValue.Contains("***PROCESS EXIT WITH WATCHED CODE***"))
					return returnValue;
				else
					return "";
			}
		}

        /// <summary>
        /// Get the current CPU usage of the target process, uses a refresh rate of 0.5 seconds
        /// </summary>
		public double GetCurrentProcessUse
		{
			get
			{
				double refresh = 500.0; // The lower the number, the more accurate.  however, a higher number gives a better, solid average.  
				// currently set to .5 sec as that is the fastest procexp will update in order to check the accuracy of this check.
				TimeSpan start = this.debuggee.TotalProcessorTime;
				Thread.Sleep((int)refresh);
				double usage = ((double)(this.debuggee.TotalProcessorTime - start).TotalMilliseconds * 100.0) / refresh;

				return usage;
			}
		}

		/// <summary>
		/// Clears the debug messages between fuzz runs.
		/// </summary>
		public void ClearDebugMessages()
		{
			this.ErrorInformation.Clear();
		}

		/// <summary>
		/// Destructor to clean up the debugee after the debugger has exited
		/// </summary>
		~Debugger()
		{
			this.KillProcess();
			if (this.DesktopHandle != IntPtr.Zero)
			{
				if (!WinAPI.CloseDesktop(this.DesktopHandle))
					throw new Exception("Error closing hidden desktop");
			}
		}

		/// <summary>
		/// Sets and starts the debugee.
		/// </summary>
		/// <param name="Path"></param>
		/// <param name="Arguments"></param>
		public void StartProcess(string Target, string Arguments = "")
		{
			this.ErrorInformation.Clear();
			this.doneStarting = false;
			StringBuilder ShortPath = new StringBuilder(Target.Length);
			WinAPI.GetShortPathName(Target, ShortPath, (uint)ShortPath.Capacity);
			Target = "\"" + ShortPath.ToString() + "\"";

			this.debuggeePath = Target;

			if (Arguments != "")
				this.ProcessArguments = "\"" + Arguments + "\"";

			this.debuggerThread = new Thread(this.StartMultithreadedProcess);

			this.debuggerThread.Start();

			// We need to wait for the program to actually startup before we return
			if (this.settings.WaitForFullStartup)
				while (!this.doneStarting) ;
		}

		/// <summary>
		/// Begins the termination sequence for the debuggee.
		/// </summary>
		public void KillProcess()
		{
			if (this.debuggerThread != null)
			{
				this.enterTerminateSequence = true;

				while (this.enterTerminateSequence)
					if (this.debuggee.HasExited)
						break;
					else
						this.debuggee.WaitForExit();

				this.enterTerminateSequence = false;
				this.debuggee.Close();

				this.debuggerThread = null;
				this.lastEvent = 0;
			}
		}

		#endregion Public_Functions

		#region private_Functions

		/// <summary>
		/// Private component to StartProcess, this is run in a seperate thread from the main thread.
		/// </summary>
		private void StartMultithreadedProcess()
		{
			WinAPI.STARTUP_INFO startup = new WinAPI.STARTUP_INFO();
			WinAPI.PROCESS_INFORMATION procInfo = new WinAPI.PROCESS_INFORMATION();

			if (this.settings.HideMainWindow)
				startup.Desktop = DesktopName;

			if (!WinAPI.CreateProcess(null, this.debuggeePath + " " + this.ProcessArguments, IntPtr.Zero, IntPtr.Zero, false, (DEBUG_PROCESS | CREATE_DEFAULT_ERROR_MODE | CREATE_NEW_CONSOLE | CREATE_NEW_PROCESS_GROUP), IntPtr.Zero, null, ref startup, ref procInfo))
				throw new Exception("Error creating the process");

			this.debuggee = Process.GetProcessById(procInfo.ProcessId);
			this.debuggee.PriorityClass = ProcessPriorityClass.RealTime;

			this.ErrorInformation.Append("Debuggee: " + this.debuggee.ProcessName + "\r\n");
			this.ErrorInformation.Append("ProcessID: " + this.debuggee.Id.ToString() + "\r\n");

			if (!WinAPI.CloseHandle(procInfo.Thread))
				throw new Exception("Error closing handle to created thread");
			if (!WinAPI.CloseHandle(procInfo.Process))
				throw new Exception("Error closing handle to created process");

			this.CheckProcessArchitecture();
			this.MainDebuggerLoop();
		}

		/// <summary>
		/// Sets a global variable depending on if the debugee is 32 or 64 bit.
		/// </summary>
		private void CheckProcessArchitecture()
		{
			IntPtr kernel32 = WinAPI.LoadLibrary("kernel32.dll");

			if (kernel32 == IntPtr.Zero)
				return;

			if (!WinAPI.GetProcAddress(kernel32, "IsWow64Process").Equals(IntPtr.Zero))
			{
				WinAPI.IsWow64Process(this.debuggee.Handle, out this.is32bit);
				this.is32bit = !this.is32bit;
			}
		}

		/// <summary>
		/// Returns the string representing the context of a given thread
		/// </summary>
		/// <param name="ThreadID"></param>
		/// <returns></returns>
		private string GetRegisterContext(uint ThreadID)
		{
			string returnValue = "";

			CONTEXT context = new CONTEXT();
			context.ContextFlags = CONTEXT_FLAGS.CONTEXT_CONTROL | CONTEXT_FLAGS.CONTEXT_INTEGER;
			IntPtr ThreadHandle = WinAPI.OpenThread(WinAPI.ThreadAccessRights.THREAD_GET_CONTEXT, false, ThreadID);
			if (ThreadHandle == IntPtr.Zero)
				throw new Exception("Error 0x" + WinAPI.GetLastError().ToString("X") + " - " + Enum.GetName(typeof(WinAPI.SYSTEM_ERROR_CODE), WinAPI.GetLastError()) + " - when getting thread handle for context");
			if (!WinAPI.GetThreadContext(ThreadHandle, ref context))
				throw new Exception("Error 0x" + WinAPI.GetLastError().ToString("X") + " - " + Enum.GetName(typeof(WinAPI.SYSTEM_ERROR_CODE), WinAPI.GetLastError()) + " - when getting thread context");

			// NEEDS ATTENTION - not tested, should confirm register values against WinDbg
			int paddingSize = ((this.is32bit) ? 8 : 16); // This check will be needed when handling 64 bit processes, currently not tested.
			paddingSize = 8; // Temporary while 32 bit is worked on.
			returnValue += "EAX=0x" + context.Eax.ToString("X").PadLeft(paddingSize, '0') + "\t\t";
			returnValue += "EBX=0x" + context.Ebx.ToString("X").PadLeft(paddingSize, '0') + "\r\n";
			returnValue += "ECX=0x" + context.Ecx.ToString("X").PadLeft(paddingSize, '0') + "\t\t";
			returnValue += "EDX=0x" + context.Edx.ToString("X").PadLeft(paddingSize, '0') + "\r\n";
			returnValue += "EDI=0x" + context.Edi.ToString("X").PadLeft(paddingSize, '0') + "\t\t";
			returnValue += "ESI=0x" + context.Esi.ToString("X").PadLeft(paddingSize, '0') + "\r\n";
			returnValue += "EBP=0x" + context.Ebp.ToString("X").PadLeft(paddingSize, '0') + "\t\t";
			returnValue += "ESP=0x" + context.Esp.ToString("X").PadLeft(paddingSize, '0') + "\r\n\t";
			returnValue += "EIP=0x" + context.Eip.ToString("X").PadLeft(paddingSize, '0');

			WinAPI.CloseHandle(ThreadHandle);

			return returnValue;
		}

		#region Debug_Events

		/// <summary>
		/// The main loop of the debugger, waits for events and processes actions accordingly.
		/// </summary>
		private void MainDebuggerLoop()
		{
			while (true)
			{
				if (this.enterTerminateSequence)
				{
					if (!WinAPI.DebugActiveProcessStop((uint)this.debuggee.Id))
						throw new Exception("Error 0x" + WinAPI.GetLastError().ToString("X") + " - " + Enum.GetName(typeof(WinAPI.SYSTEM_ERROR_CODE), WinAPI.GetLastError()) + " - when detatching from process");

					try
					{
						this.debuggee.Kill();  // XP seems to be choking on this.  Errors out with permission denied, then the same call throws an exception that the process is already dead.
						// Adding a check to see if the process has exited yet before calling this did not seem to fix it.  best fix so far is an empty try/catch, sloppy but it worked

						if (this.settings.EnableKillAlso) // Allows the debugger to kill other processes when it kills the debugee
						{
							Process[] processes = Process.GetProcessesByName(this.settings.KillAlso);

							if (processes.Length > 0)
							{
								foreach (Process p in processes)
								{
									if (p != this.debuggee)
									{
										if (!p.HasExited)
										{
											p.Kill();
										}
									}
								}
							}
						}

						this.debuggee.WaitForExit();
					}
					catch (Exception e)
					{
						try
						{
							if (!this.debuggee.HasExited)
								throw new Exception("Error - Debuggee Never Exited.  " + e.Message);
						}
						catch (Exception exception)
						{
							if (!(exception is InvalidOperationException) && !(exception.Message == "There is no process associated with the object"))
								throw exception;
						}
					}
					finally
					{
						this.enterTerminateSequence = false;
					}

					return;
				}

				if (this.WindowThread == null) // Allows us to only have one thread cleaning windows at a time.
				{
					this.WindowThread = new Thread(this.CheckWindows);
					this.WindowThread.Start();
				}

				Debug_Event Event = new Debug_Event();
				if (!WinAPI.WaitForDebugEvent(out Event, 0))
					if (WinAPI.GetLastError() == 121) // Error 121 is a timeout error, since we are not pausing at all for events.  We don't pause so that we can continue to launch threads to check windows.
						continue;
					else
						throw new DebuggerException("Error 0x" + WinAPI.GetLastError().ToString("X") + " - " + Enum.GetName(typeof(WinAPI.SYSTEM_ERROR_CODE), WinAPI.GetLastError()) + " - while waiting for debug event");

				this.lastEvent = DateTime.Now.Millisecond;

				WinAPI.ContinueStatus action = this.ProcessEvent(Event);

				if (!WinAPI.ContinueDebugEvent(Event.ProcessID, Event.ThreadID, action))
					throw new DebuggerException("Error 0x" + WinAPI.GetLastError().ToString("X") + " - " + Enum.GetName(typeof(WinAPI.SYSTEM_ERROR_CODE), WinAPI.GetLastError()) + " - while attempting to continue a debug event.");
			}
		}

		/// <summary>
		/// Check all of the windows spawned using a different thread.
		/// </summary>
		private void CheckWindows()
		{
			try
			{
				if (this.debuggee.HasExited)
					return;
			}
			catch
			{
				return;
			}

			if (this.settings.AutoCloseSpawnedWindows)
			{
				if (this.settings.HideMainWindow)
				{
					WinAPI.EnumDesktopWindows(this.DesktopHandle, new WindowCallback(this.CheckWindow), IntPtr.Zero);
				}
				else
				{
					WinAPI.EnumWindows(new WindowCallback(this.CheckWindow), IntPtr.Zero);
				}
			}

			this.WindowThread = null;
		}

        /// <summary>
        /// Callback function used when enumerating desktop windows
        /// </summary>
        /// <param name="WindowHandle"></param>
        /// <param name="Param"></param>
        /// <returns></returns>
		private bool CheckWindow(IntPtr WindowHandle, IntPtr Param)
		{
			int id;
			WinAPI.GetWindowThreadProcessId(WindowHandle, out id);

            // Process window if it belongs to the debugee 
			if (id == this.debuggee.Id)
			{
                // Check for popup windows
				IntPtr PopupWindow = WinAPI.GetWindow(WindowHandle, WinAPI.WindowFlags.GW_ENABLEDPOPUP);

				if (PopupWindow != WindowHandle && PopupWindow != IntPtr.Zero) // popup found
				{
					if (this.settings.OKbeforeCLOSE) // look for buttons to press
					{
						WinAPI.EnumChildWindows(PopupWindow, new WindowCallback(this.SearchOKandCONTINUEmessages), IntPtr.Zero);
					}

					Thread.Sleep(100);

					StringBuilder message = new StringBuilder(WinAPI.GetWindowTextLength(PopupWindow) + 1);
					WinAPI.GetWindowText(PopupWindow, message, message.Capacity);

					Console.Write("Popup: 0x" + PopupWindow.ToString("X").PadLeft(8, '0') + ", ");
					Console.WriteLine("Message: " + message);

					WinAPI.SendMessage(PopupWindow, WinAPI.WINDOW_MESSAGE.WM_CLOSE, IntPtr.Zero, IntPtr.Zero); // close window

				}

				if (this.settings.OKbeforeCLOSE && this.settings.AlwaysClick)
				{
					WinAPI.EnumChildWindows(WindowHandle, new WindowCallback(this.SearchOKandCONTINUEmessages), IntPtr.Zero); // if always clicking buttons, look for the right ones to click
				}
			}

			return true;
		}

        /// <summary>
        /// Callback function used when looking for specific buttons to click
        /// </summary>
        /// <param name="WindowHandle"></param>
        /// <param name="Param"></param>
        /// <returns></returns>
		private bool SearchOKandCONTINUEmessages(IntPtr WindowHandle, IntPtr Param)
		{
			StringBuilder message = new StringBuilder(WinAPI.GetWindowTextLength(WindowHandle) + 1);
			WinAPI.GetWindowText(WindowHandle, message, message.Capacity);

			foreach (string regex in this.PositiveResponses)
			{
				if (Regex.IsMatch(message.ToString(), regex) && Regex.Match(message.ToString(), regex).Value == message.ToString())
				{
					this.ErrorInformation.Append("Button Clicked" + "\r\n");
					this.ErrorInformation.Append("=============================================" + "\r\n");
					this.ErrorInformation.Append("Button Message = " + message + "\r\n");
					this.ErrorInformation.Append("\r\n\r\n" + "\r\n");

					WinAPI.SendMessage(WindowHandle, WinAPI.WINDOW_MESSAGE.BM_CLICK, IntPtr.Zero, IntPtr.Zero);
					break;
				}
			}

			return true;
		}

		/// <summary>
		/// Process the event, this is where most of the work for the debugger is done at run time.
		/// </summary>
		/// <param name="e"></param>
		/// <returns></returns>
		private WinAPI.ContinueStatus ProcessEvent(Debug_Event e)
		{
			switch (e.Code)
			{
				case EventCode.CREATE_PROCESS_DEBUG_INFO:
					return this.HandleCreateProcess(e);
				case EventCode.CREATE_THREAD_DEBUG_INFO:
					return this.HandleThreadCreation(e);
				case EventCode.EXCEPTION_DEBUG_INFO:
					return this.HandleExceptions(e);
				case EventCode.EXIT_PROCESS_DEBUG_INFO:
					return this.HandleProcessExit(e);
				case EventCode.EXIT_THREAD_DEBUG_INFO:
					return this.HandleExitThread(e);
				case EventCode.LOAD_DLL_DEBUG_INFO:
					return HandleLoadDLL(e);
				case EventCode.UNLOAD_DLL_DEBUG_INFO:
					return this.HandleUnloadDLL(e);
				case EventCode.RIP_INFO:
					return this.HandleRIP(e);
				case EventCode.OUTPUT_DEBUG_STRING_INFO:
					return this.HandleOutputString(e);
			}

			return WinAPI.ContinueStatus.DBG_CONTINUE;
		}

		/// <summary>
		/// Performs any actions necessary when an output string is encountered.
		/// </summary>
		/// <param name="e"></param>
		/// <returns></returns>
		private WinAPI.ContinueStatus HandleOutputString(Debug_Event e)
		{
			// This function doesn't much matter because strings and Debug_Event in C# doesn't seem to get along very well, should probably look into that.  Probably around the same time I start caring about debug strings.
			return WinAPI.ContinueStatus.DBG_CONTINUE;
		}

		/// <summary>
		/// Performs any actions necessary when a RIP event is encountered
		/// </summary>
		/// <param name="e"></param>
		/// <returns></returns>
		private WinAPI.ContinueStatus HandleRIP(Debug_Event e)
		{
			return WinAPI.ContinueStatus.DBG_CONTINUE;
		}

		/// <summary>
		/// Performs any actions necessary when a DLL is unloaded
		/// </summary>
		/// <param name="e"></param>
		/// <returns></returns>
		private WinAPI.ContinueStatus HandleUnloadDLL(Debug_Event e)
		{
			return WinAPI.ContinueStatus.DBG_CONTINUE;
		}

		/// <summary>
		/// Performs any actions necessary when a DLL is loaded
		/// </summary>
		/// <param name="e"></param>
		/// <returns></returns>
		private WinAPI.ContinueStatus HandleLoadDLL(Debug_Event e)
		{
			if (!WinAPI.CloseHandle(e.u.LoadDll.File))
				throw new Exception("Error closing file handle during dll load");
			return WinAPI.ContinueStatus.DBG_CONTINUE;
		}

		/// <summary>
		/// Performs any actions necessary when a thread exits
		/// </summary>
		/// <param name="e"></param>
		/// <returns></returns>
		private WinAPI.ContinueStatus HandleExitThread(Debug_Event e)
		{
			return WinAPI.ContinueStatus.DBG_CONTINUE;
		}

		/// <summary>
		/// Performs any actions necessary when the debuggee exits a process
		/// </summary>
		/// <param name="e"></param>
		/// <returns></returns>
		private WinAPI.ContinueStatus HandleProcessExit(Debug_Event e)
		{
			if (this.debuggee.Id == e.ProcessID)
			{
				if (this.settings.ErrorCodes.Contains((ErrorCode)e.u.ExitProcess.ExitCode))
				{
					this.ErrorInformation.Append("***PROCESS EXIT WITH WATCHED CODE***" + "\r\n");
				}
				else
				{
					this.ErrorInformation.Append("PROCESS EXIT" + "\r\n");
				}
			}
			else
			{
				this.ErrorInformation.Append("SPAWNED PROCESS EXIT" + "\r\n");
			}

			this.ErrorInformation.Append("=============================================" + "\r\n");
			this.ErrorInformation.Append("Process: " + e.ProcessID + "\r\n");
			this.ErrorInformation.Append("Thread: " + e.ThreadID + "\r\n");
			this.ErrorInformation.Append("Error: " + Enum.GetName(typeof(ErrorCode), e.u.ExitProcess.ExitCode) + " - " + e.u.ExitProcess.ExitCode.ToString("X") + "\r\n");
			this.ErrorInformation.Append("\r\n" + this.GetRegisterContext(e.ThreadID) + "\r\n");

			this.ErrorInformation.Append("\r\n\r\n" + "\r\n");

			if (this.debuggee.Id == e.ProcessID)
			{
				this.debuggee.Kill();
				this.debuggee.WaitForExit();
			}

			return WinAPI.ContinueStatus.DBG_CONTINUE;
		}

		/// <summary>
		/// Performs any actions necessary when the debuggee raises an exception
		/// </summary>
		/// <param name="e"></param>
		/// <returns></returns>
		private WinAPI.ContinueStatus HandleExceptions(Debug_Event e)
		{
			// Handle the breakpoint exception at startup, this is where we hide the debugger if necessary
			if ((ErrorCode)e.u.Exception.ExceptionRecord.ExceptionCode == ErrorCode.STATUS_BREAKPOINT && !this.doneStarting)
			{
				this.doneStarting = true;

				if (this.settings.HideDebugger)
				{
					WinAPI.BasicProcessInformation ProcessInformation = new WinAPI.BasicProcessInformation();
					int returnLength;
					WinAPI.SYSTEM_ERROR_CODE code = WinAPI.NtQueryInformationProcess(this.debuggee.Handle, 0x00, ref ProcessInformation, (uint)Marshal.SizeOf(ProcessInformation), out returnLength);
					if (code != 0)
						throw new DebuggerException("Error 0x" + WinAPI.GetLastError().ToString("X") + " - " + Enum.GetName(typeof(WinAPI.SYSTEM_ERROR_CODE), WinAPI.GetLastError()) + " - while getting PEB address. - 0x" + code.ToString("X") + " - " + Enum.GetName(typeof(ErrorCode), code));

					byte[] DebuggerPresent = new Byte[1];

					int Length;
					
					DebuggerPresent[0] = 0;
					WinAPI.WriteProcessMemory(this.debuggee.Handle, ProcessInformation.PebBaseAddress + 2, DebuggerPresent, 1, out Length);
				}

				return WinAPI.ContinueStatus.DBG_CONTINUE;
			}

			this.ErrorInformation.Append("EXCEPTION" + "\r\n");
			this.ErrorInformation.Append("=============================================" + "\r\n");
			this.ErrorInformation.Append("Process: " + e.ProcessID + "\r\n");
			this.ErrorInformation.Append("Thread: " + e.ThreadID + "\r\n");
			this.ErrorInformation.Append("Error: " + Enum.GetName(typeof(ErrorCode), e.u.Exception.ExceptionRecord.ExceptionCode) + " - " + e.u.Exception.ExceptionRecord.ExceptionCode.ToString("X") + "\r\n");
			this.ErrorInformation.Append("\r\n" + this.GetRegisterContext(e.ThreadID) + "\r\n");
			this.ErrorInformation.Append("\r\n\r\n" + "\r\n");

			return WinAPI.ContinueStatus.DBG_EXCEPTION_NOT_HANDLED;
		}

		/// <summary>
		/// Performs any actions necessary when the debuggee creates a thread
		/// </summary>
		/// <param name="e"></param>
		/// <returns></returns>
		private WinAPI.ContinueStatus HandleThreadCreation(Debug_Event e)
		{
			return WinAPI.ContinueStatus.DBG_CONTINUE;
		}

		/// <summary>
		/// Performs any actions necessary when a process is created.
		/// </summary>
		/// <param name="e"></param>
		/// <returns></returns>
		private WinAPI.ContinueStatus HandleCreateProcess(Debug_Event e)
		{
			if (!WinAPI.CloseHandle(e.u.CreateProcessInfo.File))
				throw new Exception("Error closing file handle in create process event");

			return WinAPI.ContinueStatus.DBG_CONTINUE;
		}

		#endregion Debug_Events

		#endregion private_Functions

		#region DLL_Imports

        // Miscellaneous constants, should be folded into the WinAPI structures at some point
		private const uint INFINITE = 0xFFFFFFFF;
		private const int MAXIMUM_SUPPORTED_EXTENSION = 512;
		private const int SIZE_OF_80387_REGISTERS = 80;
		private const uint STANDARD_RIGHTS_REQUIRED = (uint)WinAPI.ThreadAccessRights.DELETE | (uint)WinAPI.ThreadAccessRights.READ_CONTROL | (uint)WinAPI.ThreadAccessRights.WRITE_DAC | (uint)WinAPI.ThreadAccessRights.WRITE_OWNER;
		private const uint NORMAL_PRIORITY_CLASS = 0x20;
		private const uint HIGH_PRIORITY_CLASS = 0x80;
		private const uint DEBUG_PROCESS = 0x01;
		private const uint CREATE_NEW_CONSOLE = 0x10;
		private const uint CREATE_NEW_PROCESS_GROUP = 0x200;
		private const uint CREATE_DEFAULT_ERROR_MODE = 0x04000000;

		/// <summary>
		/// Windows API Interface.
		/// </summary>
		private static class WinAPI
		{
			// Kernel32 DLL Imports
			#region Kernel32

			[DllImport("Kernel32.dll", CallingConvention = CallingConvention.StdCall)]
			public static extern int GetLastError();

			[DllImport("Kernel32.dll", CallingConvention = CallingConvention.StdCall)]
			public static extern Boolean DebugActiveProcess([In] UInt32 dwProcessId);

			[DllImport("Kernel32.dll", CallingConvention = CallingConvention.StdCall)]
			public static extern bool DebugBreakProcess([In] IntPtr ProcessHandle);

			[DllImport("Kernel32.dll", CallingConvention = CallingConvention.StdCall)]
			public static extern bool ReadProcessMemory([In] IntPtr ProcessHandle, [In] IntPtr BaseAddress, [In, Out] Byte[] Buffer, [In] int BufferSize, [Out] out int BytesRead);

			[DllImport("Kernel32.dll", CallingConvention = CallingConvention.StdCall)]
			public static extern bool WriteProcessMemory([In] IntPtr ProcessHandle, [In] IntPtr BaseAddress, [In] byte[] Buffer, [In] int BufferSize, [Out] out int BytesWritten);

			[DllImport("Kernel32.dll", CallingConvention = CallingConvention.StdCall)]
			public static extern IntPtr GetProcAddress([In] IntPtr Module, [In] string ProcedureName);

			[DllImport("Kernel32.dll", CallingConvention = CallingConvention.StdCall)]
			public static extern bool IsWow64Process([In] IntPtr Module, [Out] out bool WoW64Process);

			[DllImport("Kernel32.dll", CallingConvention = CallingConvention.StdCall)]
			public static extern IntPtr LoadLibrary([In] string LibraryName);

			[DllImport("Kernel32.dll", CallingConvention = CallingConvention.StdCall)]
			public static extern bool WaitForDebugEvent([Out] out Debug_Event Event, [In] uint Milliseconds);

			[DllImport("Kernel32.dll", CallingConvention = CallingConvention.StdCall, SetLastError = true)]
			public static extern bool ContinueDebugEvent([In] uint ProcessId, [In] uint ThreadId, [In] ContinueStatus ContinueStatus);

			[DllImport("Kernel32.dll", CallingConvention = CallingConvention.StdCall)]
			public static extern IntPtr OpenThread([In] ThreadAccessRights DesiredAccess, [In] bool InheritHandle, [In] uint ThreadID);

			[DllImport("Kernel32.dll", CallingConvention = CallingConvention.StdCall)]
			public static extern bool CloseHandle([In] IntPtr Handle);

			[DllImport("Kernel32.dll", CallingConvention = CallingConvention.StdCall)]
			public static extern bool CreateProcess(string ApplicationName, string CommandLine, IntPtr ProcessAttributes, IntPtr ThreadAttributes, bool InheritHandles, uint CreationFlags, IntPtr Environment, string CurrentDirectory, ref STARTUP_INFO StartupInfo, ref PROCESS_INFORMATION ProcessInformation);

			[DllImport("Kernel32.dll", CallingConvention = CallingConvention.StdCall)]
			public static extern bool TerminateThread(IntPtr Thread, uint ExitCode);

			[DllImport("Kernel32.dll", CallingConvention = CallingConvention.StdCall)]
			public static extern IntPtr OpenThread(uint DesiredAccess, bool InheritHandle, uint ThreadID);

			[DllImport("Kernel32.dll", CallingConvention = CallingConvention.StdCall)]
			public static extern bool TerminateProcess([In] IntPtr Process, [In] uint ExitCode);

			[DllImport("Kernel32.dll", CallingConvention = CallingConvention.StdCall)]
			public static extern bool DebugActiveProcessStop([In] uint ProcessId);

			[DllImport("Kernel32.dll", CallingConvention = CallingConvention.StdCall)]
			public static extern bool SetThreadContext([In] IntPtr Thread, [In] ref CONTEXT Context);

			[DllImport("Kernel32.dll", CallingConvention = CallingConvention.StdCall)]
			public static extern bool GetThreadContext([In] IntPtr Thread, [In, Out] ref CONTEXT Context);

			[DllImport("Kernel32.dll", CallingConvention = CallingConvention.StdCall)]
			public static extern bool WriteProcessMemory([In] IntPtr Process, [In] IntPtr BaseAddress, [In] byte[] Buffer, uint Size, [Out] out UIntPtr NumberBytesWritten);

			[DllImport("Kernel32.dll", CallingConvention = CallingConvention.StdCall)]
			public static extern uint GetShortPathName([In] string LongPath, [Out] StringBuilder ShortPath, [In] uint BufferLength);

			#endregion Kernel32

			#region Ntdll

			[DllImport("Ntdll.dll", CallingConvention = CallingConvention.StdCall)]
			public static extern SYSTEM_ERROR_CODE NtQueryInformationProcess(IntPtr ProcessHandle, int ProcessInformationClass, ref BasicProcessInformation ProcessInformation, uint ProcessInformationLength, out int ReturnLength);

			#endregion Ntdll

			// User32 DLL Imports
			#region User32

			[DllImport("User32.dll", CallingConvention = CallingConvention.StdCall)]
			public static extern IntPtr CreateDesktop(string Desktop, IntPtr Device, IntPtr DevMode, uint Flags, uint DesiredAccess, IntPtr lpsa);

			[DllImport("User32.dll", CallingConvention = CallingConvention.StdCall)]
			public static extern bool CloseDesktop([In] IntPtr Desktop);

			[DllImport("User32.dll", CallingConvention = CallingConvention.StdCall)]
			public static extern IntPtr GetDesktopWindow();

			[DllImport("User32.dll", CallingConvention = CallingConvention.StdCall)]
			public static extern bool EnumWindows([In] Debugger.WindowCallback Callback, [In] IntPtr Param);

			[DllImport("User32.dll", CallingConvention = CallingConvention.StdCall)]
			public static extern bool CloseWindow([In] IntPtr WindowHandle);

			[DllImport("User32.dll", CallingConvention = CallingConvention.StdCall)]
			public static extern bool IsChild([In] IntPtr ParentWindow, [In] IntPtr ChildWindow);

			[DllImport("User32.dll", CallingConvention = CallingConvention.StdCall)]
			public static extern int GetWindowText([In] IntPtr WindowHandle, StringBuilder Text, int MaxCount);

			[DllImport("User32.dll", CallingConvention = CallingConvention.StdCall)]
			public static extern int GetWindowTextLength([In] IntPtr WindowHandle);

			[DllImport("User32.dll", CallingConvention = CallingConvention.StdCall)]
			public static extern IntPtr SendMessage([In] IntPtr WindowHandle, [In] WINDOW_MESSAGE Message, [In] IntPtr wParam, [In] IntPtr lParam);

			[DllImport("User32.dll", CallingConvention = CallingConvention.StdCall)]
			public static extern IntPtr GetActiveWindow();

			[DllImport("User32.dll", CallingConvention = CallingConvention.StdCall)]
			public static extern uint GetWindowThreadProcessId([In] IntPtr WindowHandle, [Out, Optional] out int ProcessID);

			[DllImport("User32.dll", CallingConvention = CallingConvention.StdCall)]
			public static extern bool EnumChildWindows([In, Optional] IntPtr ParentWindow, [In] Debugger.WindowCallback Callback, [In] IntPtr Param);

			[DllImport("User32.dll", CallingConvention = CallingConvention.StdCall)]
			public static extern IntPtr GetParent([In] IntPtr WindowHandle);

			[DllImport("User32.dll", CallingConvention = CallingConvention.StdCall)]
			public static extern IntPtr GetAncestor([In] IntPtr WindowHandle, [In] WindowFlags Flags);

			[DllImport("User32.dll", CallingConvention = CallingConvention.StdCall)]
			public static extern IntPtr GetWindow([In] IntPtr WindowHandle, [In] WindowFlags Cmd);

			[DllImport("User32.dll", CallingConvention = CallingConvention.StdCall)]
			public static extern bool EnumDesktopWindows([In, Optional] IntPtr DesktopHandle, [In] Debugger.WindowCallback Callback, [In] IntPtr Param);

			#endregion User32

			// Structures used by the Windows API
			#region Structs

			[StructLayout(LayoutKind.Sequential)]
			public struct BasicProcessInformation
			{
				public IntPtr Reserved1;
				public IntPtr PebBaseAddress;
				public IntPtr Reserved2;
				public IntPtr Reserved2_1;
				public IntPtr UniqueProcessId;
				public IntPtr InheritedFromUniqueProcessId;
			}

			[StructLayout(LayoutKind.Sequential)]
			public struct STARTUP_INFO
			{
				public int cb;
				public string Reserved;
				public string Desktop;
				public string Title;
				public int dwX;
				public int dwY;
				public int dwXSize;
				public int dwYSize;
				public int dwXCountChars;
				public int dwYCountChars;
				public int Flags;
				public short ShowWindow;
				public short cb2;
				public IntPtr Reserved2;
				public IntPtr StdInput;
				public IntPtr StdOutput;
				public IntPtr StdError;
			}

			[StructLayout(LayoutKind.Sequential)]
			public struct PROCESS_INFORMATION
			{
				public IntPtr Process;
				public IntPtr Thread;
				public int ProcessId;
				public int ThreadId;
			}

			#endregion Structs

			// Enumerated types used by the Windows API
			#region Enums

			public enum WindowFlags : uint
			{
				GW_HWNDFIRST = 0,
				GW_HWNDLAST = 1,
				GW_HWNDNEXT = 2,
				GW_HWNPREV = 3,
				GW_OWNER = 4,
				GW_CHILD = 5,
				GW_ENABLEDPOPUP = 6
			}

			public enum WINDOW_MESSAGE : uint
			{
				BN_CLICKED = 0x0000,
				BM_CLICK = 0x00F5,
				WM_CLOSE = 0x0010,
				SC_CLOSE = 0xF060
			}

			public enum ACCESS_MASK : uint
			{
				DESKTOP_CREATEMENU = 0x4,
				DESKTOP_CREATEWINDOW = 0x2,
				DESKTOP_ENUMERATE = 0x40,
				DESKTOP_HOOKCONTROL = 0x8,
				DESKTOP_JOURNALPLAYBACK = 0x20,
				DESKTOP_JOURNALRECORD = 0x10,
				DESKTOP_READOBJECTS = 0x1,
				DESKTOP_SWITCHDESKTOP = 0x100,
				DESKTOP_WRITEOBJECTS = 0x80,

				GENERIC_ALL = (DESKTOP_CREATEMENU | DESKTOP_CREATEWINDOW | DESKTOP_ENUMERATE | DESKTOP_HOOKCONTROL | DESKTOP_JOURNALPLAYBACK | DESKTOP_JOURNALRECORD | DESKTOP_READOBJECTS | DESKTOP_SWITCHDESKTOP | DESKTOP_WRITEOBJECTS | STANDARD_RIGHTS_REQUIRED)
			}

			public enum ThreadAccessRights : uint
			{
				DELETE = 0x00010000,
				READ_CONTROL = 0x00020000,
				SYNCHRONIZE = 0x00100000,
				WRITE_DAC = 0x00040000,
				WRITE_OWNER = 0x00080000,
				THREAD_GET_CONTEXT = 0x0008
			}

			public enum ContinueStatus : uint
			{
				DBG_CONTINUE = 0x00010002,
				DBG_EXCEPTION_NOT_HANDLED = 0x80010001
			}

			public enum SYSTEM_ERROR_CODE : uint
			{
				ERROR_SUCCESS = 0x0,
				ERROR_INVALID_FUNCTION = 0x1,
				ERROR_FILE_NOT_FOUND = 0x2,
				ERROR_PATH_NOT_FOUND = 0x3,
				ERROR_TOO_MANY_OPEN_FILES = 0x4,
				ERROR_ACCESS_DENIED = 0x5,
				ERROR_INVALID_HANDLE = 0x6,
				ERROR_ARENA_TRASHED = 0x7,
				ERROR_NOT_ENOUGH_MEMORY = 0x8,
				ERROR_INVALID_BLOCK = 0x9,
				ERROR_BAD_ENVIRONMENT = 0xA,
				ERROR_BAD_FORMAT = 0xB,
				ERROR_INVALID_ACCESS = 0xC,
				ERROR_INVALID_DATA = 0xD,
				ERROR_OUTOFMEMORY = 0xE,
				ERROR_INVALID_DRIVE = 0xF,
				ERROR_CURRENT_DIRECTORY = 0x10,
				ERROR_NOT_SAME_DEVICE = 0x11,
				ERROR_NO_MORE_FILES = 0x12,
				ERROR_WRITE_PROTECT = 0x13,
				ERROR_BAD_UNIT = 0x14,
				ERROR_NOT_READY = 0x15,
				ERROR_BAD_COMMAND = 0x16,
				ERROR_CRC = 0x17,
				ERROR_BAD_LENGTH = 0x18,
				ERROR_SEEK = 0x19,
				ERROR_NOT_DOS_DISK = 0x1A,
				ERROR_SECTOR_NOT_FOUND = 0x1B,
				ERROR_OUT_OF_PAPER = 0x1C,
				ERROR_WRITE_FAULT = 0x1D,
				ERROR_READ_FAULT = 0x1E,
				ERROR_GEN_FAILURE = 0x1F,
				ERROR_SHARING_VIOLATION = 0x20,
				ERROR_LOCK_VIOLATION = 0x21,
				ERROR_WRONG_DISK = 0x22,
				ERROR_SHARING_BUFFER_EXCEEDED = 0x24,
				ERROR_HANDLE_EOF = 0x26,
				ERROR_HANDLE_DISK_FULL = 0x27,
				ERROR_NOT_SUPPORTED = 0x32,
				ERROR_REM_NOT_LIST = 0x33,
				ERROR_DUP_NAME = 0x34,
				ERROR_BAD_NETPATH = 0x35,
				ERROR_NETWORK_BUSY = 0x36,
				ERROR_DEV_NOT_EXIST = 0x37,
				ERROR_TOO_MANY_CMDS = 0x38,
				ERROR_ADAP_HDW_ERR = 0x39,
				ERROR_BAD_NET_RESP = 0x3A,
				ERROR_UNEXP_NET_ERR = 0x3B,
				ERROR_BAD_REM_ADAP = 0x3C,
				ERROR_PRINTQ_FULL = 0x3D,
				ERROR_NO_SPOOL_SPACE = 0x3E,
				ERROR_PRINT_CANCELLED = 0x3F,
				ERROR_NETNAME_DELETED = 0x40,
				ERROR_NETWORK_ACCESS_DENIED = 0x41,
				ERROR_BAD_DEV_TYPE = 0x42,
				ERROR_BAD_NET_NAME = 0x43,
				ERROR_TOO_MANY_NAMES = 0x44,
				ERROR_TOO_MANY_SESS = 0x45,
				ERROR_SHARING_PAUSED = 0x46,
				ERROR_REQ_NOT_ACCEP = 0x47,
				ERROR_REDIR_PAUSED = 0x48,
				ERROR_FILE_EXISTS = 0x50,
				ERROR_CANNOT_MAKE = 0x52,
				ERROR_FAIL_I24 = 0x53,
				ERROR_OUT_OF_STRUCTURES = 0x54,
				ERROR_ALREADY_ASSIGNED = 0x55,
				ERROR_INVALID_PASSWORD = 0x56,
				ERROR_INVALID_PARAMETER = 0x57,
				ERROR_NET_WRITE_FAULT = 0x58,
				ERROR_NO_PROC_SLOTS = 0x59,
				ERROR_TOO_MANY_SEMAPHORES = 0x64,
				ERROR_EXCL_SEM_ALREADY_OWNED = 0x65,
				ERROR_SEM_IS_SET = 0x66,
				ERROR_TOO_MANY_SEM_REQUESTS = 0x67,
				ERROR_INVALID_AT_INTERRUPT_TIME = 0x68,
				ERROR_SEM_OWNER_DIED = 0x69,
				ERROR_SEM_USER_LIMIT = 0x6A,
				ERROR_DISK_CHANGE = 0x6B,
				ERROR_DRIVE_LOCKED = 0x6C,
				ERROR_BROKEN_PIPE = 0x6D,
				ERROR_OPEN_FAILED = 0x6E,
				ERROR_BUFFER_OVERFLOW = 0x6F,
				ERROR_DISK_FULL = 0x70,
				ERROR_NO_MORE_SEARCH_HANDLES = 0x71,
				ERROR_INVALID_TARGET_HANDLE = 0x72,
				ERROR_INVALID_CATEGORY = 0x75,
				ERROR_INVALID_VERIFY_SWITCH = 0x76,
				ERROR_BAD_DRIVER_LEVEL = 0x77,
				ERROR_CALL_NOT_IMPLEMENTED = 0x78,
				ERROR_SEM_TIMEOUT = 0x79,
				ERROR_INSUFFICIENT_BUFFER = 0x7A,
				ERROR_INVALID_NAME = 0x7B,
				ERROR_INVALID_LEVEL = 0x7C,
				ERROR_NO_VOLUME_LABEL = 0x7D,
				ERROR_MOD_NOT_FOUND = 0x7E,
				ERROR_PROC_NOT_FOUND = 0x7F,
				ERROR_WAIT_NO_CHILDREN = 0x80,
				ERROR_CHILD_NOT_COMPLETE = 0x81,
				ERROR_DIRECT_ACCESS_HANDLE = 0x82,
				ERROR_NEGATIVE_SEEK = 0x83,
				ERROR_SEEK_ON_DEVICE = 0x84,
				ERROR_IS_JOIN_TARGET = 0x85,
				ERROR_IS_JOINED = 0x86,
				ERROR_IS_SUBSTED = 0x87,
				ERROR_NOT_JOINED = 0x88,
				ERROR_NOT_SUBSTED = 0x89,
				ERROR_JOIN_TO_JOIN = 0x8A,
				ERROR_SUBST_TO_SUBST = 0x8B,
				ERROR_JOIN_TO_SUBST = 0x8C,
				ERROR_SUBST_TO_JOIN = 0x8D,
				ERROR_BUSY_DRIVE = 0x8E,
				ERROR_SAME_DRIVE = 0x8F,
				ERROR_DIR_NOT_ROOT = 0x90,
				ERROR_DIR_NOT_EMPTY = 0x91,
				ERROR_IS_SUBST_PATH = 0x92,
				ERROR_IS_JOIN_PATH = 0x93,
				ERROR_PATH_BUSY = 0x94,
				ERROR_IS_SUBST_TARGET = 0x95,
				ERROR_SYSTEM_TRACE = 0x96,
				ERROR_INVALID_EVENT_COUNT = 0x97,
				ERROR_TOO_MANY_MUXWAITERS = 0x98,
				ERROR_INVALID_LIST_FORMAT = 0x99,
				ERROR_LABEL_TOO_LONG = 0x9A,
				ERROR_TOO_MANY_TCBS = 0x9B,
				ERROR_SIGNAL_REFUSED = 0x9C,
				ERROR_DISCARDED = 0x9D,
				ERROR_NOT_LOCKED = 0x9E,
				ERROR_BAD_THREADID_ADDR = 0x9F,
				ERROR_BAD_ARGUMENTS = 0xA0,
				ERROR_BAD_PATHNAME = 0xA1,
				ERROR_SIGNAL_PENDING = 0xA2,
				ERROR_MAX_THRDS_REACHED = 0xA4,
				ERROR_LOCK_FAILED = 0xA7,
				ERROR_BUSY = 0xAA,
				ERROR_DEVICE_SUPPORT_IN_PROGRESS = 0xAB,
				ERROR_CANCEL_VIOLATION = 0xAD,
				ERROR_ATOMIC_LOCKS_NOT_SUPPORTED = 0xAE,
				ERROR_INVALID_SEGMENT_NUMBER = 0xB4,
				ERROR_INVALID_ORDINAL = 0xB6,
				ERROR_ALREADY_EXISTS = 0xB7,
				ERROR_INVALID_FLAG_NUMBER = 0xBA,
				ERROR_SEM_NOT_FOUND = 0xBB,
				ERROR_INVALID_STARTING_CODESEG = 0xBC,
				ERROR_INVALID_STACKSEG = 0xBD,
				ERROR_INVALID_MODULETYPE = 0xBE,
				ERROR_INVALID_EXE_SIGNATURE = 0xBF,
				ERROR_EXE_MARKED_INVALID = 0xC0,
				ERROR_BAD_EXE_FORMAT = 0xC1,
				ERROR_ITERATED_DATA_EXCEEDS_64k = 0xC2,
				ERROR_INVALID_MINALLOCSIZE = 0xC3,
				ERROR_DYNLINK_FROM_INVALID_RING = 0xC4,
				ERROR_IOPL_NOT_ENABLED = 0xC5,
				ERROR_INVALID_SEGDPL = 0xC6,
				ERROR_AUTODATASEG_EXCEEDS_64k = 0xC7,
				ERROR_RING2SEG_MUST_BE_MOVABLE = 0xC8,
				ERROR_RELOC_CHAIN_XEEDS_SEGLIM = 0xC9,
				ERROR_INFLOOP_IN_RELOC_CHAIN = 0xCA,
				ERROR_ENVVAR_NOT_FOUND = 0xCB,
				ERROR_NO_SIGNAL_SENT = 0xCD,
				ERROR_FILENAME_EXCED_RANGE = 0xCE,
				ERROR_RING2_STACK_IN_USE = 0xCF,
				ERROR_META_EXPANSION_TOO_LONG = 0xD0,
				ERROR_INVALID_SIGNAL_NUMBER = 0xD1,
				ERROR_THREAD_1_INACTIVE = 0xD2,
				ERROR_LOCKED = 0xD4,
				ERROR_TOO_MANY_MODULES = 0xD6,
				ERROR_NESTING_NOT_ALLOWED = 0xD7,
				ERROR_EXE_MACHINE_TYPE_MISMATCH = 0xD8,
				ERROR_EXE_CANNOT_MODIFY_SIGNED_BINARY = 0xD9,
				ERROR_EXE_CANNOT_MODIFY_STRONG_SIGNED_BINARY = 0xDA,
				ERROR_FILE_CHECKED_OUT = 0xDC,
				ERROR_CHECKOUT_REQUIRED = 0xDD,
				ERROR_BAD_FILE_TYPE = 0xDE,
				ERROR_FILE_TOO_LARGE = 0xDF,
				ERROR_FORMS_AUTH_REQUIRED = 0xE0,
				ERROR_VIRUS_INFECTED = 0xE1,
				ERROR_VIRUS_DELETED = 0xE2,
				ERROR_PIPE_LOCAL = 0xE5,
				ERROR_BAD_PIPE = 0xE6,
				ERROR_PIPE_BUSY = 0xE7,
				ERROR_NO_DATA = 0xE8,
				ERROR_PIPE_NOT_CONNECTED = 0xE9,
				ERROR_MORE_DATA = 0xEA,
				ERROR_VC_DISCONNECTED = 0xF0,
				ERROR_INVALID_EA_NAME = 0xFE,
				ERROR_EA_LIST_INCONSISTENT = 0xFF,
				WAIT_TIMEOUT = 0x102,
				ERROR_NO_MORE_ITEMS = 0x103,
				ERROR_CANNOT_COPY = 0x10A,
				ERROR_DIRECTORY = 0x10B,
				ERROR_EAS_DIDNT_FIT = 0x113,
				ERROR_EA_FILE_CORRUPT = 0x114,
				ERROR_EA_TABLE_FULL = 0x115,
				ERROR_INVALID_EA_HANDLE = 0x116,
				ERROR_EAS_NOT_SUPPORTED = 0x11A,
				ERROR_NOT_OWNER = 0x120,
				ERROR_TOO_MANY_POSTS = 0x12A,
				ERROR_PARTIAL_COPY = 0x12B,
				ERROR_OPLOCK_NOT_GRANTED = 0x12C,
				ERROR_INVALID_OPLOCK_PROTOCOL = 0x12D,
				ERROR_DISK_TOO_FRAGMENTED = 0x12E,
				ERROR_DELETE_PENDING = 0x12F,
				ERROR_INCOMPATIBLE_WITH_GLOBAL_SHORT_NAME_REGISTRY_SETTING = 0x130,
				ERROR_SHORT_NAMES_NOT_ENABLED_ON_VOLUME = 0x131,
				ERROR_SECURITY_STREAM_IS_INCONSISTENT = 0x132,
				ERROR_INVALID_LOCK_RANGE = 0x133,
				ERROR_IMAGE_SUBSYSTEM_NOT_PRESENT = 0x134,
				ERROR_NOTIFICATION_GUID_ALREADY_DEFINED = 0x135,
				ERROR_INVALID_EXCEPTION_HANDLER = 0x136,
				ERROR_DUPLICATE_PRIVILEGES = 0x137,
				ERROR_NO_RANGES_PROCESSED = 0x138,
				ERROR_NOT_ALLOWED_ON_SYSTEM_FILE = 0x139,
				ERROR_DISK_RESOURCES_EXHAUSTED = 0x13A,
				ERROR_INVALID_TOKEN = 0x13B,
				ERROR_DEVICE_FEATURE_NOT_SUPPORTED = 0x13C,
				ERROR_MR_MID_NOT_FOUND = 0x13D,
				ERROR_SCOPE_NOT_FOUND = 0x13E,
				ERROR_UNDEFINED_SCOPE = 0x13F,
				ERROR_INVALID_CAP = 0x140,
				ERROR_DEVICE_UNREACHABLE = 0x141,
				ERROR_DEVICE_NO_RESOURCES = 0x142,
				ERROR_DATA_CHECKSUM_ERROR = 0x143,
				ERROR_INTERMIXED_SECURE_EA_OPERATION = 0x144,
				ERROR_SPECIFIED_COPY_READ = 0x145,
				ERROR_REPAIR_DEFERRED = 0x146,
				ERROR_OFFSET_ALIGNMENT_VIOLATION = 0x147,
				ERROR_INVALID_FIELD_IN_PARAMETER_LIST = 0x148,
				ERROR_OPERATION_IN_PROGRESS = 0x149,
				ERROR_BAD_DEVICE_PATH = 0x14A,
				ERROR_TOO_MANY_DESCRIPTORS = 0x14B,
				ERROR_SCRUB_DATA_DISABLED = 0x14C,
				ERROR_FAIL_NOACTION_REBOOT = 0x15E,
				ERROR_FAIL_SHUTDOWN = 0x15F,
				ERROR_FAIL_RESTART = 0x160,
				ERROR_MAX_SESSIONS_REACHED = 0x161,
				ERROR_THREAD_MODE_ALREADY_BACKGROUND = 0x190,
				ERROR_THREAD_MODE_NOT_BACKGROUND = 0x191,
				ERROR_PROCESS_MODE_ALREADY_BACKGROUND = 0x192,
				ERROR_PROCESS_MODE_NOT_BACKGROUND = 0x193,
				ERROR_INVALID_ADDRESS = 0x1E7
			}

			#endregion Enums
		}

		#endregion DLL_Imports

		#region private_Structure_Definitions

		/// <summary>
		/// Function Pointer to handle EnumWindow Callbacks
		/// </summary>
		/// <param name="WindowHandle"></param>
		/// <param name="Param"></param>
		/// <returns></returns>
		private delegate bool WindowCallback(IntPtr WindowHandle, IntPtr Param);

		/// <summary>
		/// The context of a thread running on a 32-bit platform
		/// </summary>
		[StructLayout(LayoutKind.Sequential)]
		private struct CONTEXT
		{
			public CONTEXT_FLAGS ContextFlags;

			public uint Dr0;
			public uint Dr1;
			public uint Dr2;
			public uint Dr3;
			public uint Dr6;
			public uint Dr7;

			public FLOATING_SAVE_AREA FloatSave;

			public uint SegGs;
			public uint SegFs;
			public uint SegEs;
			public uint SegDs;

			public uint Edi;
			public uint Esi;
			public uint Ebx;
			public uint Edx;
			public uint Ecx;
			public uint Eax;

			public uint Ebp;
			public uint Eip;
			public uint SegCs;
			public uint EFLags;
			public uint Esp;
			public uint SegSs;

			[MarshalAs(UnmanagedType.ByValArray, SizeConst = MAXIMUM_SUPPORTED_EXTENSION)]
			public byte[] ExtendedRegisters;
		}

		/// <summary>
		/// Flags to specify when getting a thread's context
		/// </summary>
		private enum CONTEXT_FLAGS : uint
		{
			CONTEXT_i386 = 0x10000,
			CONTEXT_CONTROL = CONTEXT_i386 | 0x01,
			CONTEXT_INTEGER = CONTEXT_i386 | 0x02,
			CONTEXT_SEGMENTS = CONTEXT_i386 | 0x04,
			CONTEXT_FLOATING_POINT = CONTEXT_i386 | 0x08,
			CONTEXT_DEBUG_REGISTERS = CONTEXT_i386 | 0x10,
			CONTEXT_EXTENDED_REGISTERS = CONTEXT_i386 | 0x20,
			CONTEXT_FULL = CONTEXT_CONTROL | CONTEXT_INTEGER | CONTEXT_SEGMENTS,
			CONTEXT_ALL = CONTEXT_CONTROL | CONTEXT_INTEGER | CONTEXT_SEGMENTS | CONTEXT_FLOATING_POINT | CONTEXT_DEBUG_REGISTERS | CONTEXT_EXTENDED_REGISTERS
		}

		/// <summary>
		/// The floating point data, probably never be used
		/// </summary>
		private struct FLOATING_SAVE_AREA
		{
			public uint ControlWord;
			public uint StatusWord;
			public uint TagWord;
			public uint ErrorOffset;
			public uint DataOffset;
			public uint DataSelector;

			[MarshalAs(UnmanagedType.ByValArray, SizeConst = SIZE_OF_80387_REGISTERS)]
			public byte[] RegisterArea;

			public uint CrONpxState;
		}

		/// <summary>
		/// Represents what type of event was generated by the debuggee
		/// </summary>
		private enum EventCode : uint
		{
			EXCEPTION_DEBUG_INFO = 1,
			CREATE_THREAD_DEBUG_INFO = 2,
			CREATE_PROCESS_DEBUG_INFO = 3,
			EXIT_THREAD_DEBUG_INFO = 4,
			EXIT_PROCESS_DEBUG_INFO = 5,
			LOAD_DLL_DEBUG_INFO = 6,
			UNLOAD_DLL_DEBUG_INFO = 7,
			OUTPUT_DEBUG_STRING_INFO = 8,
			RIP_INFO = 9
		}

		/// <summary>
		/// Holds debug event data.
		/// </summary>
		[StructLayout(LayoutKind.Sequential)]
		private struct Debug_Event
		{
			public EventCode Code;
			public uint ProcessID;
			public uint ThreadID;
			public Union u;
		}

		/// <summary>
		/// Holds debug details, only used by Debug_Event and should not be created individually
		/// </summary>
		[StructLayout(LayoutKind.Explicit)]
		private struct Union
		{
			[FieldOffset(0)]
			public EXCEPTION_DEBUG_INFO Exception;

			[FieldOffset(0)]
			public CREATE_THREAD_DEBUG_INFO CreateThread;

			[FieldOffset(0)]
			public CREATE_PROCESS_DEBUG_INFO CreateProcessInfo;

			[FieldOffset(0)]
			public EXIT_THREAD_DEBUG_INFO ExitThread;

			[FieldOffset(0)]
			public EXIT_PROCESS_DEBUG_INFO ExitProcess;

			[FieldOffset(0)]
			public LOAD_DLL_DEBUG_INFO LoadDll;

			[FieldOffset(0)]
			public UNLOAD_DLL_DEBUG_INFO UnloadDll;

			[FieldOffset(0)]
			public OUTPUT_DEBUG_STRING_INFO DebugString;

			[FieldOffset(0)]
			public RIP_INFO RipInfo;
		}

		/// <summary>
		/// Holds exception details, only used by Union and should not be created individually
		/// </summary>
		[StructLayout(LayoutKind.Sequential)]
		private struct EXCEPTION_DEBUG_INFO
		{
			public EXCEPTION_RECORD ExceptionRecord;
			public uint FirstChance;
		}

		/// <summary>
		/// Holds thread creation details, only used by Union and should not be created individually
		/// </summary>
		[StructLayout(LayoutKind.Sequential)]
		private struct CREATE_THREAD_DEBUG_INFO
		{
			public IntPtr Thread;
			public IntPtr ThreadLocalBase;
			public IntPtr StartAddress;
		}

		/// <summary>
		/// Holds process creation details, only used by Union and should not be created individually
		/// </summary>
		[StructLayout(LayoutKind.Sequential)]
		private struct CREATE_PROCESS_DEBUG_INFO
		{
			public IntPtr File;
			public IntPtr Process;
			public IntPtr Thread;
			public IntPtr BaseOfImage;
			public uint DebugInfoFileOffset;
			public uint DebugInfoSize;
			public IntPtr ThreadLocalBase;
			public IntPtr StartAddress;
			public IntPtr ImageName;
			public ushort Unicode;
		}

		/// <summary>
		/// Holds the exit code for the thread, only used by Union and should not be created individually
		/// </summary>
		[StructLayout(LayoutKind.Sequential)]
		private struct EXIT_THREAD_DEBUG_INFO
		{
			public uint ExitCode;
		}

		/// <summary>
		/// Holds the exit code for the process, only used by Union and should not be created individually
		/// </summary>
		[StructLayout(LayoutKind.Sequential)]
		private struct EXIT_PROCESS_DEBUG_INFO
		{
			public uint ExitCode;
		}

		/// <summary>
		/// Holds the loaded DLL information, only used by Union and should not be created individually
		/// </summary>
		[StructLayout(LayoutKind.Sequential)]
		private struct LOAD_DLL_DEBUG_INFO
		{
			public IntPtr File;
			public IntPtr BaseOfDll;
			public uint DebugInfoFileOffset;
			public uint DebugInfoSize;
			public IntPtr ImageName;
			public ushort Unicode;
		}

		/// <summary>
		/// Holds the unloaded DLL information, only used by Union and should not be created individually
		/// </summary>
		[StructLayout(LayoutKind.Sequential)]
		private struct UNLOAD_DLL_DEBUG_INFO
		{
			public IntPtr BaseOfDll;
		}

		/// <summary>
		/// Holds the output debug string information, only used by Union and should not be created individually
		/// </summary>
		[StructLayout(LayoutKind.Sequential)]
		private struct OUTPUT_DEBUG_STRING_INFO
		{
			//[MarshalAs(UnmanagedType.LPStr)]
			//public string DebugStringData;
			public IntPtr DebugStringData;
			public ushort Unicode;
			public ushort DebugStringLength;
		}

		/// <summary>
		/// Holds the error information for the RIP debug event, only used by Union and should not be created individually
		/// </summary>
		[StructLayout(LayoutKind.Sequential)]
		private struct RIP_INFO
		{
			public uint Error;
			public uint Type;
		}

		/// <summary>
		/// Holds individual exception information, only used by Exception_Debug_Info and should not be created individually
		/// </summary>
		[StructLayout(LayoutKind.Sequential)]
		private struct EXCEPTION_RECORD
		{
			public uint ExceptionCode;
			public uint ExceptionFlags;
			public IntPtr ExceptionRecord;
			public IntPtr ExceptionAddress;
			public uint NumberParameters;

			// NEEDS ATTENTION - this should be marshaled but it isn't supported yet, declared each element manually in order to make it work properly.

			//[MarshalAs(UnmanagedType.ByValArray, SizeConst = 15, ArraySubType = UnmanagedType.U4)]
			//public uint[] exceptioninformation;
			public IntPtr ExceptionInformation0;
			public IntPtr ExceptionInformation1;
			public IntPtr ExceptionInformation2;
			public IntPtr ExceptionInformation3;
			public IntPtr ExceptionInformation4;
			public IntPtr ExceptionInformation5;
			public IntPtr ExceptionInformation6;
			public IntPtr ExceptionInformation7;
			public IntPtr ExceptionInformation8;
			public IntPtr ExceptionInformation9;
			public IntPtr ExceptionInformation10;
			public IntPtr ExceptionInformation11;
			public IntPtr ExceptionInformation12;
			public IntPtr ExceptionInformation13;
			public IntPtr ExceptionInformation14;
		}

		#endregion private_Structure_Definitions
	}
}